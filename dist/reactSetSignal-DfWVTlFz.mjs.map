{"version":3,"file":"reactSetSignal-DfWVTlFz.mjs","sources":["../node_modules/.pnpm/mutative@1.3.0/node_modules/mutative/dist/mutative.esm.mjs","../node_modules/.pnpm/react-set-signal@1.0.11_rea_df80552af63807f4b56bec79b54823d6/node_modules/react-set-signal/dist/reactSetSignal.js"],"sourcesContent":["const Operation = {\n    Remove: 'remove',\n    Replace: 'replace',\n    Add: 'add',\n};\n\n// Don't use `Symbol()` just for 3rd party access the draft\nconst PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nconst RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\nconst iteratorSymbol = Symbol.iterator;\nconst dataTypes = {\n    mutable: 'mutable',\n    immutable: 'immutable',\n};\n\nconst internal = {};\n\nfunction has(target, key) {\n    return target instanceof Map\n        ? target.has(key)\n        : Object.prototype.hasOwnProperty.call(target, key);\n}\nfunction getDescriptor(target, key) {\n    if (key in target) {\n        let prototype = Reflect.getPrototypeOf(target);\n        while (prototype) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n            if (descriptor)\n                return descriptor;\n            prototype = Reflect.getPrototypeOf(prototype);\n        }\n    }\n    return;\n}\nfunction isBaseSetInstance(obj) {\n    return Object.getPrototypeOf(obj) === Set.prototype;\n}\nfunction isBaseMapInstance(obj) {\n    return Object.getPrototypeOf(obj) === Map.prototype;\n}\n\nfunction latest(proxyDraft) {\n    var _a;\n    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;\n}\n/**\n * Check if the value is a draft\n */\nfunction isDraft(target) {\n    return !!getProxyDraft(target);\n}\nfunction getProxyDraft(value) {\n    if (typeof value !== 'object')\n        return null;\n    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];\n}\nfunction getValue(value) {\n    var _a;\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? ((_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original) : value;\n}\n/**\n * Check if a value is draftable\n */\nfunction isDraftable(value, options) {\n    if (!value || typeof value !== 'object')\n        return false;\n    let markResult;\n    return (Object.getPrototypeOf(value) === Object.prototype ||\n        Array.isArray(value) ||\n        value instanceof Map ||\n        value instanceof Set ||\n        (!!(options === null || options === void 0 ? void 0 : options.mark) &&\n            ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n                typeof markResult === 'function')));\n}\nfunction getPath(target, path = []) {\n    if (Object.hasOwnProperty.call(target, 'key')) {\n        // check if the parent is a draft and the original value is not equal to the current value\n        const parentCopy = target.parent.copy;\n        const proxyDraft = getProxyDraft(get(parentCopy, target.key));\n        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {\n            return null;\n        }\n        const isSet = target.parent.type === 3 /* DraftType.Set */;\n        const key = isSet\n            ? Array.from(target.parent.setMap.keys()).indexOf(target.key)\n            : target.key;\n        // check if the key is still in the next state parent\n        if (!((isSet && parentCopy.size > key) || has(parentCopy, key)))\n            return null;\n        path.push(key);\n    }\n    if (target.parent) {\n        return getPath(target.parent, path);\n    }\n    // `target` is root draft.\n    path.reverse();\n    try {\n        // check if the path is valid\n        resolvePath(target.copy, path);\n    }\n    catch (e) {\n        return null;\n    }\n    return path;\n}\nfunction getType(target) {\n    if (Array.isArray(target))\n        return 1 /* DraftType.Array */;\n    if (target instanceof Map)\n        return 2 /* DraftType.Map */;\n    if (target instanceof Set)\n        return 3 /* DraftType.Set */;\n    return 0 /* DraftType.Object */;\n}\nfunction get(target, key) {\n    return getType(target) === 2 /* DraftType.Map */ ? target.get(key) : target[key];\n}\nfunction set(target, key, value) {\n    const type = getType(target);\n    if (type === 2 /* DraftType.Map */) {\n        target.set(key, value);\n    }\n    else {\n        target[key] = value;\n    }\n}\nfunction peek(target, key) {\n    const state = getProxyDraft(target);\n    const source = state ? latest(state) : target;\n    return source[key];\n}\nfunction isEqual(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\nfunction revokeProxy(proxyDraft) {\n    if (!proxyDraft)\n        return;\n    while (proxyDraft.finalities.revoke.length > 0) {\n        const revoke = proxyDraft.finalities.revoke.pop();\n        revoke();\n    }\n}\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nfunction escapePath(path, pathAsArray) {\n    return pathAsArray\n        ? path\n        : ['']\n            .concat(path)\n            .map((_item) => {\n            const item = `${_item}`;\n            if (item.indexOf('/') === -1 && item.indexOf('~') === -1)\n                return item;\n            return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n            .join('/');\n}\nfunction unescapePath(path) {\n    if (Array.isArray(path))\n        return path;\n    return path\n        .split('/')\n        .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n        .slice(1);\n}\nfunction resolvePath(base, path) {\n    for (let index = 0; index < path.length - 1; index += 1) {\n        const key = path[index];\n        // use `index` in Set draft\n        base = get(getType(base) === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n        }\n    }\n    return base;\n}\n\nfunction strictCopy(target) {\n    const copy = Object.create(Object.getPrototypeOf(target));\n    Reflect.ownKeys(target).forEach((key) => {\n        let desc = Reflect.getOwnPropertyDescriptor(target, key);\n        if (desc.enumerable && desc.configurable && desc.writable) {\n            copy[key] = target[key];\n            return;\n        }\n        // for freeze\n        if (!desc.writable) {\n            desc.writable = true;\n            desc.configurable = true;\n        }\n        if (desc.get || desc.set)\n            desc = {\n                configurable: true,\n                writable: true,\n                enumerable: desc.enumerable,\n                value: target[key],\n            };\n        Reflect.defineProperty(copy, key, desc);\n    });\n    return copy;\n}\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\nfunction shallowCopy(original, options) {\n    let markResult;\n    if (Array.isArray(original)) {\n        return Array.prototype.concat.call(original);\n    }\n    else if (original instanceof Set) {\n        if (!isBaseSetInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original.values());\n        }\n        return Set.prototype.difference\n            ? Set.prototype.difference.call(original, new Set())\n            : new Set(original.values());\n    }\n    else if (original instanceof Map) {\n        if (!isBaseMapInstance(original)) {\n            const SubClass = Object.getPrototypeOf(original).constructor;\n            return new SubClass(original);\n        }\n        return new Map(original);\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.mark) &&\n        ((markResult = options.mark(original, dataTypes)),\n            markResult !== undefined) &&\n        markResult !== dataTypes.mutable) {\n        if (markResult === dataTypes.immutable) {\n            return strictCopy(original);\n        }\n        else if (typeof markResult === 'function') {\n            if ((options.enablePatches || options.enableAutoFreeze)) {\n                throw new Error(`You can't use mark and patches or auto freeze together.`);\n            }\n            return markResult();\n        }\n        throw new Error(`Unsupported mark result: ${markResult}`);\n    }\n    else if (typeof original === 'object' &&\n        Object.getPrototypeOf(original) === Object.prototype) {\n        // For best performance with shallow copies,\n        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n        const copy = {};\n        Object.keys(original).forEach((key) => {\n            copy[key] = original[key];\n        });\n        Object.getOwnPropertySymbols(original).forEach((key) => {\n            if (propIsEnum.call(original, key)) {\n                copy[key] = original[key];\n            }\n        });\n        return copy;\n    }\n    else {\n        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);\n    }\n}\nfunction ensureShallowCopy(target) {\n    if (target.copy)\n        return;\n    target.copy = shallowCopy(target.original, target.options);\n}\nfunction deepClone(target) {\n    if (!isDraftable(target))\n        return getValue(target);\n    if (Array.isArray(target))\n        return target.map(deepClone);\n    if (target instanceof Map) {\n        const iterable = Array.from(target.entries()).map(([k, v]) => [\n            k,\n            deepClone(v),\n        ]);\n        if (!isBaseMapInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Map(iterable);\n    }\n    if (target instanceof Set) {\n        const iterable = Array.from(target).map(deepClone);\n        if (!isBaseSetInstance(target)) {\n            const SubClass = Object.getPrototypeOf(target).constructor;\n            return new SubClass(iterable);\n        }\n        return new Set(iterable);\n    }\n    const copy = Object.create(Object.getPrototypeOf(target));\n    for (const key in target)\n        copy[key] = deepClone(target[key]);\n    return copy;\n}\nfunction cloneIfNeeded(target) {\n    return isDraft(target) ? deepClone(target) : target;\n}\n\nfunction markChanged(proxyDraft) {\n    var _a;\n    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n    if (!proxyDraft.operated) {\n        proxyDraft.operated = true;\n        if (proxyDraft.parent) {\n            markChanged(proxyDraft.parent);\n        }\n    }\n}\n\nfunction throwFrozenError() {\n    throw new Error('Cannot modify frozen object');\n}\nfunction deepFreeze(target, subKey, updatedValues, stack, keys) {\n    {\n        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();\n        stack = stack !== null && stack !== void 0 ? stack : [];\n        keys = keys !== null && keys !== void 0 ? keys : [];\n        const value = updatedValues.has(target)\n            ? updatedValues.get(target)\n            : target;\n        if (stack.length > 0) {\n            const index = stack.indexOf(value);\n            if (value && typeof value === 'object' && index !== -1) {\n                if (stack[0] === value) {\n                    throw new Error(`Forbids circular reference`);\n                }\n                throw new Error(`Forbids circular reference: ~/${keys\n                    .slice(0, index)\n                    .map((key, index) => {\n                    if (typeof key === 'symbol')\n                        return `[${key.toString()}]`;\n                    const parent = stack[index];\n                    if (typeof key === 'object' &&\n                        (parent instanceof Map || parent instanceof Set))\n                        return Array.from(parent.keys()).indexOf(key);\n                    return key;\n                })\n                    .join('/')}`);\n            }\n            stack.push(value);\n            keys.push(subKey);\n        }\n        else {\n            stack.push(value);\n        }\n    }\n    if (Object.isFrozen(target) || isDraft(target)) {\n        {\n            stack.pop();\n            keys.pop();\n        }\n        return;\n    }\n    const type = getType(target);\n    switch (type) {\n        case 2 /* DraftType.Map */:\n            for (const [key, value] of target) {\n                deepFreeze(key, key, updatedValues, stack, keys);\n                deepFreeze(value, key, updatedValues, stack, keys);\n            }\n            target.set = target.clear = target.delete = throwFrozenError;\n            break;\n        case 3 /* DraftType.Set */:\n            for (const value of target) {\n                deepFreeze(value, value, updatedValues, stack, keys);\n            }\n            target.add = target.clear = target.delete = throwFrozenError;\n            break;\n        case 1 /* DraftType.Array */:\n            Object.freeze(target);\n            let index = 0;\n            for (const value of target) {\n                deepFreeze(value, index, updatedValues, stack, keys);\n                index += 1;\n            }\n            break;\n        default:\n            Object.freeze(target);\n            // ignore non-enumerable or symbol properties\n            Object.keys(target).forEach((name) => {\n                const value = target[name];\n                deepFreeze(value, name, updatedValues, stack, keys);\n            });\n    }\n    {\n        stack.pop();\n        keys.pop();\n    }\n}\n\nfunction forEach(target, iter) {\n    const type = getType(target);\n    if (type === 0 /* DraftType.Object */) {\n        Reflect.ownKeys(target).forEach((key) => {\n            iter(key, target[key], target);\n        });\n    }\n    else if (type === 1 /* DraftType.Array */) {\n        let index = 0;\n        for (const entry of target) {\n            iter(index, entry, target);\n            index += 1;\n        }\n    }\n    else {\n        target.forEach((entry, index) => iter(index, entry, target));\n    }\n}\n\nfunction handleValue(target, handledSet, options) {\n    if (isDraft(target) ||\n        !isDraftable(target, options) ||\n        handledSet.has(target) ||\n        Object.isFrozen(target))\n        return;\n    const isSet = target instanceof Set;\n    const setMap = isSet ? new Map() : undefined;\n    handledSet.add(target);\n    forEach(target, (key, value) => {\n        var _a;\n        if (isDraft(value)) {\n            const proxyDraft = getProxyDraft(value);\n            ensureShallowCopy(proxyDraft);\n            // A draft where a child node has been changed, or assigned a value\n            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original;\n            // final update value\n            set(isSet ? setMap : target, key, updatedValue);\n        }\n        else {\n            handleValue(value, handledSet, options);\n        }\n    });\n    if (setMap) {\n        const set = target;\n        const values = Array.from(set);\n        set.clear();\n        values.forEach((value) => {\n            set.add(setMap.has(value) ? setMap.get(value) : value);\n        });\n    }\n}\nfunction finalizeAssigned(proxyDraft, key) {\n    // handle the draftable assigned valuesï¼Œ and the value is not a draft\n    const copy = proxyDraft.type === 3 /* DraftType.Set */ ? proxyDraft.setMap : proxyDraft.copy;\n    if (proxyDraft.finalities.revoke.length > 1 &&\n        proxyDraft.assignedMap.get(key) &&\n        copy) {\n        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);\n    }\n}\nfunction finalizeSetValue(target) {\n    if (target.type === 3 /* DraftType.Set */ && target.copy) {\n        target.copy.clear();\n        target.setMap.forEach((value) => {\n            target.copy.add(getValue(value));\n        });\n    }\n}\nfunction finalizePatches(target, generatePatches, patches, inversePatches) {\n    const shouldFinalize = target.operated &&\n        target.assignedMap &&\n        target.assignedMap.size > 0 &&\n        !target.finalized;\n    if (shouldFinalize) {\n        if (patches && inversePatches) {\n            const basePath = getPath(target);\n            if (basePath) {\n                generatePatches(target, basePath, patches, inversePatches);\n            }\n        }\n        target.finalized = true;\n    }\n}\nfunction markFinalization(target, key, value, generatePatches) {\n    const proxyDraft = getProxyDraft(value);\n    if (proxyDraft) {\n        // !case: assign the draft value\n        if (!proxyDraft.callbacks) {\n            proxyDraft.callbacks = [];\n        }\n        proxyDraft.callbacks.push((patches, inversePatches) => {\n            var _a;\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.copy) {\n                    updatedValue = proxyDraft.copy;\n                }\n                finalizeSetValue(target);\n                finalizePatches(target, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n        });\n        if (target.options.enableAutoFreeze) {\n            // !case: assign the draft value in cross draft tree\n            if (proxyDraft.finalities !== target.finalities) {\n                target.options.enableAutoFreeze = false;\n            }\n        }\n    }\n    if (isDraftable(value, target.options)) {\n        // !case: assign the non-draft value\n        target.finalities.draft.push(() => {\n            const copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            if (isEqual(get(copy, key), value)) {\n                finalizeAssigned(target, key);\n            }\n        });\n    }\n}\n\nfunction generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {\n    let { original, assignedMap, options } = proxyState;\n    let copy = proxyState.copy;\n    if (copy.length < original.length) {\n        [original, copy] = [copy, original];\n        [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let index = 0; index < original.length; index += 1) {\n        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(copy[index]),\n            });\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n                value: cloneIfNeeded(original[index]),\n            });\n        }\n    }\n    for (let index = original.length; index < copy.length; index += 1) {\n        const _path = basePath.concat([index]);\n        const path = escapePath(_path, pathAsArray);\n        patches.push({\n            op: Operation.Add,\n            path,\n            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n            value: cloneIfNeeded(copy[index]),\n        });\n    }\n    if (original.length < copy.length) {\n        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n        // For performance, here we only generate an operation that replaces the length of the array,\n        // which is inconsistent with JSON Patch specification\n        const { arrayLengthAssignment = true } = options.enablePatches;\n        if (arrayLengthAssignment) {\n            const _path = basePath.concat(['length']);\n            const path = escapePath(_path, pathAsArray);\n            inversePatches.push({\n                op: Operation.Replace,\n                path,\n                value: original.length,\n            });\n        }\n        else {\n            for (let index = copy.length; original.length < index; index -= 1) {\n                const _path = basePath.concat([index - 1]);\n                const path = escapePath(_path, pathAsArray);\n                inversePatches.push({\n                    op: Operation.Remove,\n                    path,\n                });\n            }\n        }\n    }\n}\nfunction generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {\n    assignedMap.forEach((assignedValue, key) => {\n        const originalValue = get(original, key);\n        const value = cloneIfNeeded(get(copy, key));\n        const op = !assignedValue\n            ? Operation.Remove\n            : has(original, key)\n                ? Operation.Replace\n                : Operation.Add;\n        if (isEqual(originalValue, value) && op === Operation.Replace)\n            return;\n        const _path = basePath.concat(key);\n        const path = escapePath(_path, pathAsArray);\n        patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n        inversePatches.push(op === Operation.Add\n            ? { op: Operation.Remove, path }\n            : op === Operation.Remove\n                ? { op: Operation.Add, path, value: originalValue }\n                : { op: Operation.Replace, path, value: originalValue });\n    });\n}\nfunction generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {\n    let index = 0;\n    original.forEach((value) => {\n        if (!copy.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Add,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n    index = 0;\n    copy.forEach((value) => {\n        if (!original.has(value)) {\n            const _path = basePath.concat([index]);\n            const path = escapePath(_path, pathAsArray);\n            patches.push({\n                op: Operation.Add,\n                path,\n                value,\n            });\n            inversePatches.unshift({\n                op: Operation.Remove,\n                path,\n                value,\n            });\n        }\n        index += 1;\n    });\n}\nfunction generatePatches(proxyState, basePath, patches, inversePatches) {\n    const { pathAsArray = true } = proxyState.options.enablePatches;\n    switch (proxyState.type) {\n        case 0 /* DraftType.Object */:\n        case 2 /* DraftType.Map */:\n            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 1 /* DraftType.Array */:\n            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n        case 3 /* DraftType.Set */:\n            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);\n    }\n}\n\nlet readable = false;\nconst checkReadable = (value, options, ignoreCheckDraftable = false) => {\n    if (typeof value === 'object' &&\n        value !== null &&\n        (!isDraftable(value, options) || ignoreCheckDraftable) &&\n        !readable) {\n        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);\n    }\n};\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nfunction unsafe(callback) {\n    readable = true;\n    let result;\n    try {\n        result = callback();\n    }\n    finally {\n        readable = false;\n    }\n    return result;\n}\n\nconst mapHandler = {\n    get size() {\n        const current = latest(getProxyDraft(this));\n        return current.size;\n    },\n    has(key) {\n        return latest(getProxyDraft(this)).has(key);\n    },\n    set(key, value) {\n        const target = getProxyDraft(this);\n        const source = latest(target);\n        if (!source.has(key) || !isEqual(source.get(key), value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, true);\n            target.copy.set(key, value);\n            markFinalization(target, key, value, generatePatches);\n        }\n        return this;\n    },\n    delete(key) {\n        if (!this.has(key)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (target.original.has(key)) {\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap.delete(key);\n        }\n        target.copy.delete(key);\n        return true;\n    },\n    clear() {\n        const target = getProxyDraft(this);\n        if (!this.size)\n            return;\n        ensureShallowCopy(target);\n        markChanged(target);\n        target.assignedMap = new Map();\n        for (const [key] of target.original) {\n            target.assignedMap.set(key, false);\n        }\n        target.copy.clear();\n    },\n    forEach(callback, thisArg) {\n        const target = getProxyDraft(this);\n        latest(target).forEach((_value, _key) => {\n            callback.call(thisArg, this.get(_key), _key, this);\n        });\n    },\n    get(key) {\n        var _a, _b;\n        const target = getProxyDraft(this);\n        const value = latest(target).get(key);\n        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n        if (target.options.strict) {\n            checkReadable(value, target.options, mutable);\n        }\n        if (mutable) {\n            return value;\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // drafted or reassigned\n        if (value !== target.original.get(key)) {\n            return value;\n        }\n        const draft = internal.createDraft({\n            original: value,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        ensureShallowCopy(target);\n        target.copy.set(key, draft);\n        return draft;\n    },\n    keys() {\n        return latest(getProxyDraft(this)).keys();\n    },\n    values() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.values(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value,\n                };\n            },\n        };\n    },\n    entries() {\n        const iterator = this.keys();\n        return {\n            [iteratorSymbol]: () => this.entries(),\n            next: () => {\n                const result = iterator.next();\n                if (result.done)\n                    return result;\n                const value = this.get(result.value);\n                return {\n                    done: false,\n                    value: [result.value, value],\n                };\n            },\n        };\n    },\n    [iteratorSymbol]() {\n        return this.entries();\n    },\n};\nconst mapHandlerKeys = Reflect.ownKeys(mapHandler);\n\nconst getNextIterator = (target, iterator, { isValuesIterator }) => () => {\n    var _a, _b;\n    const result = iterator.next();\n    if (result.done)\n        return result;\n    const key = result.value;\n    let value = target.setMap.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;\n    if (target.options.strict) {\n        checkReadable(key, target.options, mutable);\n    }\n    if (!mutable &&\n        !currentDraft &&\n        isDraftable(key, target.options) &&\n        !target.finalized &&\n        target.original.has(key)) {\n        // draft a draftable original set item\n        const proxy = internal.createDraft({\n            original: key,\n            parentDraft: target,\n            key,\n            finalities: target.finalities,\n            options: target.options,\n        });\n        target.setMap.set(key, proxy);\n        value = proxy;\n    }\n    else if (currentDraft) {\n        // drafted\n        value = currentDraft.proxy;\n    }\n    return {\n        done: false,\n        value: isValuesIterator ? value : [value, value],\n    };\n};\nconst setHandler = {\n    get size() {\n        const target = getProxyDraft(this);\n        return target.setMap.size;\n    },\n    has(value) {\n        const target = getProxyDraft(this);\n        // reassigned or non-draftable values\n        if (target.setMap.has(value))\n            return true;\n        ensureShallowCopy(target);\n        const valueProxyDraft = getProxyDraft(value);\n        // drafted\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))\n            return true;\n        return false;\n    },\n    add(value) {\n        const target = getProxyDraft(this);\n        if (!this.has(value)) {\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(value, true);\n            target.setMap.set(value, value);\n            markFinalization(target, value, value, generatePatches);\n        }\n        return this;\n    },\n    delete(value) {\n        if (!this.has(value)) {\n            return false;\n        }\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        const valueProxyDraft = getProxyDraft(value);\n        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {\n            // delete drafted\n            target.assignedMap.set(valueProxyDraft.original, false);\n            return target.setMap.delete(valueProxyDraft.original);\n        }\n        if (!valueProxyDraft && target.setMap.has(value)) {\n            // non-draftable values\n            target.assignedMap.set(value, false);\n        }\n        else {\n            // reassigned\n            target.assignedMap.delete(value);\n        }\n        // delete reassigned or non-draftable values\n        return target.setMap.delete(value);\n    },\n    clear() {\n        if (!this.size)\n            return;\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        markChanged(target);\n        for (const value of target.original) {\n            target.assignedMap.set(value, false);\n        }\n        target.setMap.clear();\n    },\n    values() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.values(),\n            next: getNextIterator(target, iterator, { isValuesIterator: true }),\n        };\n    },\n    entries() {\n        const target = getProxyDraft(this);\n        ensureShallowCopy(target);\n        const iterator = target.setMap.keys();\n        return {\n            [Symbol.iterator]: () => this.entries(),\n            next: getNextIterator(target, iterator, {\n                isValuesIterator: false,\n            }),\n        };\n    },\n    keys() {\n        return this.values();\n    },\n    [iteratorSymbol]() {\n        return this.values();\n    },\n    forEach(callback, thisArg) {\n        const iterator = this.values();\n        let result = iterator.next();\n        while (!result.done) {\n            callback.call(thisArg, result.value, result.value, this);\n            result = iterator.next();\n        }\n    },\n};\nif (Set.prototype.difference) {\n    // for compatibility with new Set methods\n    // https://github.com/tc39/proposal-set-methods\n    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\n    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\n    Object.assign(setHandler, {\n        intersection(other) {\n            return Set.prototype.intersection.call(new Set(this.values()), other);\n        },\n        union(other) {\n            return Set.prototype.union.call(new Set(this.values()), other);\n        },\n        difference(other) {\n            return Set.prototype.difference.call(new Set(this.values()), other);\n        },\n        symmetricDifference(other) {\n            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);\n        },\n        isSubsetOf(other) {\n            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n        },\n        isSupersetOf(other) {\n            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n        },\n        isDisjointFrom(other) {\n            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n        },\n    });\n}\nconst setHandlerKeys = Reflect.ownKeys(setHandler);\n\nconst proxyHandler = {\n    get(target, key, receiver) {\n        var _a, _b;\n        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];\n        // Improve draft reading performance by caching the draft copy.\n        if (copy && target.finalities.draftsCache.has(copy)) {\n            return copy;\n        }\n        if (key === PROXY_DRAFT)\n            return target;\n        let markResult;\n        if (target.options.mark) {\n            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n            const value = key === 'size' &&\n                (target.original instanceof Map || target.original instanceof Set)\n                ? Reflect.get(target.original, key)\n                : Reflect.get(target.original, key, receiver);\n            markResult = target.options.mark(value, dataTypes);\n            if (markResult === dataTypes.mutable) {\n                if (target.options.strict) {\n                    checkReadable(value, target.options, true);\n                }\n                return value;\n            }\n        }\n        const source = latest(target);\n        if (source instanceof Map && mapHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);\n            }\n            const handle = mapHandler[key];\n            return handle.bind(target.proxy);\n        }\n        if (source instanceof Set && setHandlerKeys.includes(key)) {\n            if (key === 'size') {\n                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);\n            }\n            const handle = setHandler[key];\n            return handle.bind(target.proxy);\n        }\n        if (!has(source, key)) {\n            const desc = getDescriptor(source, key);\n            return desc\n                ? `value` in desc\n                    ? desc.value\n                    : // !case: support for getter\n                        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)\n                : undefined;\n        }\n        const value = source[key];\n        if (target.options.strict) {\n            checkReadable(value, target.options);\n        }\n        if (target.finalized || !isDraftable(value, target.options)) {\n            return value;\n        }\n        // Ensure that the assigned values are not drafted\n        if (value === peek(target.original, key)) {\n            ensureShallowCopy(target);\n            target.copy[key] = createDraft({\n                original: target.original[key],\n                parentDraft: target,\n                key: target.type === 1 /* DraftType.Array */ ? Number(key) : key,\n                finalities: target.finalities,\n                options: target.options,\n            });\n            // !case: support for custom shallow copy function\n            if (typeof markResult === 'function') {\n                const subProxyDraft = getProxyDraft(target.copy[key]);\n                ensureShallowCopy(subProxyDraft);\n                // Trigger a custom shallow copy to update to a new copy\n                markChanged(subProxyDraft);\n                return subProxyDraft.copy;\n            }\n            return target.copy[key];\n        }\n        if (isDraft(value)) {\n            target.finalities.draftsCache.add(value);\n        }\n        return value;\n    },\n    set(target, key, value) {\n        var _a;\n        if (target.type === 3 /* DraftType.Set */ || target.type === 2 /* DraftType.Map */) {\n            throw new Error(`Map/Set draft does not support any property assignment.`);\n        }\n        let _key;\n        if (target.type === 1 /* DraftType.Array */ &&\n            key !== 'length' &&\n            !(Number.isInteger((_key = Number(key))) &&\n                _key >= 0 &&\n                (key === 0 || _key === 0 || String(_key) === String(key)))) {\n            throw new Error(`Only supports setting array indices and the 'length' property.`);\n        }\n        const desc = getDescriptor(latest(target), key);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // !case: cover the case of setter\n            desc.set.call(target.proxy, value);\n            return true;\n        }\n        const current = peek(latest(target), key);\n        const currentProxyDraft = getProxyDraft(current);\n        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n            // !case: ignore the case of assigning the original draftable value to a draft\n            target.copy[key] = value;\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            target.assignedMap.set(key, false);\n            return true;\n        }\n        // !case: handle new props with value 'undefined'\n        if (isEqual(value, current) &&\n            (value !== undefined || has(target.original, key)))\n            return true;\n        ensureShallowCopy(target);\n        markChanged(target);\n        if (has(target.original, key) && isEqual(value, target.original[key])) {\n            // !case: handle the case of assigning the original non-draftable value to a draft\n            target.assignedMap.delete(key);\n        }\n        else {\n            target.assignedMap.set(key, true);\n        }\n        target.copy[key] = value;\n        markFinalization(target, key, value, generatePatches);\n        return true;\n    },\n    has(target, key) {\n        return key in latest(target);\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(latest(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n        const source = latest(target);\n        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n        if (!descriptor)\n            return descriptor;\n        return {\n            writable: true,\n            configurable: target.type !== 1 /* DraftType.Array */ || key !== 'length',\n            enumerable: descriptor.enumerable,\n            value: source[key],\n        };\n    },\n    getPrototypeOf(target) {\n        return Reflect.getPrototypeOf(target.original);\n    },\n    setPrototypeOf() {\n        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n    },\n    defineProperty() {\n        throw new Error(`Cannot call 'defineProperty()' on drafts`);\n    },\n    deleteProperty(target, key) {\n        var _a;\n        if (target.type === 1 /* DraftType.Array */) {\n            return proxyHandler.set.call(this, target, key, undefined, target.proxy);\n        }\n        if (peek(target.original, key) !== undefined || key in target.original) {\n            // !case: delete an existing key\n            ensureShallowCopy(target);\n            markChanged(target);\n            target.assignedMap.set(key, false);\n        }\n        else {\n            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();\n            // The original non-existent key has been deleted\n            target.assignedMap.delete(key);\n        }\n        if (target.copy)\n            delete target.copy[key];\n        return true;\n    },\n};\nfunction createDraft(createDraftOptions) {\n    const { original, parentDraft, key, finalities, options } = createDraftOptions;\n    const type = getType(original);\n    const proxyDraft = {\n        type,\n        finalized: false,\n        parent: parentDraft,\n        original,\n        copy: null,\n        proxy: null,\n        finalities,\n        options,\n        // Mapping of draft Set items to their corresponding draft values.\n        setMap: type === 3 /* DraftType.Set */\n            ? new Map(original.entries())\n            : undefined,\n    };\n    // !case: undefined as a draft map key\n    if (key || 'key' in createDraftOptions) {\n        proxyDraft.key = key;\n    }\n    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */ ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);\n    finalities.revoke.push(revoke);\n    proxyDraft.proxy = proxy;\n    if (parentDraft) {\n        const target = parentDraft;\n        target.finalities.draft.push((patches, inversePatches) => {\n            var _a, _b;\n            const oldProxyDraft = getProxyDraft(proxy);\n            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n            let copy = target.type === 3 /* DraftType.Set */ ? target.setMap : target.copy;\n            const draft = get(copy, key);\n            const proxyDraft = getProxyDraft(draft);\n            if (proxyDraft) {\n                // assign the updated value to the copy object\n                let updatedValue = proxyDraft.original;\n                if (proxyDraft.operated) {\n                    updatedValue = getValue(draft);\n                }\n                finalizeSetValue(proxyDraft);\n                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n                if (target.options.enableAutoFreeze) {\n                    target.options.updatedValues =\n                        (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();\n                    target.options.updatedValues.set(updatedValue, proxyDraft.original);\n                }\n                // final update value\n                set(copy, key, updatedValue);\n            }\n            // !case: handle the deleted key\n            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {\n                callback(patches, inversePatches);\n            });\n        });\n    }\n    else {\n        // !case: handle the root draft\n        const target = getProxyDraft(proxy);\n        target.finalities.draft.push((patches, inversePatches) => {\n            finalizeSetValue(target);\n            finalizePatches(target, generatePatches, patches, inversePatches);\n        });\n    }\n    return proxy;\n}\ninternal.createDraft = createDraft;\nfunction finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {\n    var _a;\n    const proxyDraft = getProxyDraft(result);\n    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;\n    const hasReturnedValue = !!returnedValue.length;\n    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {\n        while (proxyDraft.finalities.draft.length > 0) {\n            const finalize = proxyDraft.finalities.draft.pop();\n            finalize(patches, inversePatches);\n        }\n    }\n    const state = hasReturnedValue\n        ? returnedValue[0]\n        : proxyDraft\n            ? proxyDraft.operated\n                ? proxyDraft.copy\n                : proxyDraft.original\n            : result;\n    if (proxyDraft)\n        revokeProxy(proxyDraft);\n    if (enableAutoFreeze) {\n        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);\n    }\n    return [\n        state,\n        patches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n            : patches,\n        inversePatches && hasReturnedValue\n            ? [{ op: Operation.Replace, path: [], value: original }]\n            : inversePatches,\n    ];\n}\n\nfunction draftify(baseState, options) {\n    var _a;\n    const finalities = {\n        draft: [],\n        revoke: [],\n        handledSet: new WeakSet(),\n        draftsCache: new WeakSet(),\n    };\n    let patches;\n    let inversePatches;\n    if (options.enablePatches) {\n        patches = [];\n        inversePatches = [];\n    }\n    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable ||\n        !isDraftable(baseState, options);\n    const draft = isMutable\n        ? baseState\n        : createDraft({\n            original: baseState,\n            parentDraft: null,\n            finalities,\n            options,\n        });\n    return [\n        draft,\n        (returnedValue = []) => {\n            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);\n            return (options.enablePatches\n                ? [finalizedState, finalizedPatches, finalizedInversePatches]\n                : finalizedState);\n        },\n    ];\n}\n\nfunction handleReturnValue(options) {\n    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n    forEach(value, (key, item, source) => {\n        const proxyDraft = getProxyDraft(item);\n        // just handle the draft which is created by the same rootDraft\n        if (proxyDraft &&\n            rootDraft &&\n            proxyDraft.finalities === rootDraft.finalities) {\n            options.isContainDraft = true;\n            const currentValue = proxyDraft.original;\n            // final update value, but just handle return value\n            if (source instanceof Set) {\n                const arr = Array.from(source);\n                source.clear();\n                arr.forEach((_item) => source.add(key === _item ? currentValue : _item));\n            }\n            else {\n                set(source, key, currentValue);\n            }\n        }\n        else if (typeof item === 'object' && item !== null) {\n            options.value = item;\n            options.isRoot = false;\n            handleReturnValue(options);\n        }\n    });\n    if (isRoot) {\n        if (!options.isContainDraft)\n            console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);\n        if (useRawReturn) {\n            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);\n        }\n    }\n}\nfunction getCurrent(target) {\n    var _a;\n    const proxyDraft = getProxyDraft(target);\n    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))\n        return target;\n    const type = getType(target);\n    if (proxyDraft && !proxyDraft.operated)\n        return proxyDraft.original;\n    let currentValue;\n    function ensureShallowCopy() {\n        currentValue =\n            type === 2 /* DraftType.Map */\n                ? !isBaseMapInstance(target)\n                    ? new (Object.getPrototypeOf(target).constructor)(target)\n                    : new Map(target)\n                : type === 3 /* DraftType.Set */\n                    ? Array.from(proxyDraft.setMap.values())\n                    : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);\n    }\n    if (proxyDraft) {\n        // It's a proxy draft, let's create a shallow copy eagerly\n        proxyDraft.finalized = true;\n        try {\n            ensureShallowCopy();\n        }\n        finally {\n            proxyDraft.finalized = false;\n        }\n    }\n    else {\n        // It's not a proxy draft, let's use the target directly and let's see\n        // lazily if we need to create a shallow copy\n        currentValue = target;\n    }\n    forEach(currentValue, (key, value) => {\n        if (proxyDraft && isEqual(get(proxyDraft.original, key), value))\n            return;\n        const newValue = getCurrent(value);\n        if (newValue !== value) {\n            if (currentValue === target)\n                ensureShallowCopy();\n            set(currentValue, key, newValue);\n        }\n    });\n    if (type === 3 /* DraftType.Set */) {\n        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;\n        return !isBaseSetInstance(value)\n            ? new (Object.getPrototypeOf(value).constructor)(currentValue)\n            : new Set(currentValue);\n    }\n    return currentValue;\n}\nfunction current(target) {\n    if (!isDraft(target)) {\n        throw new Error(`current() is only used for Draft, parameter: ${target}`);\n    }\n    return getCurrent(target);\n}\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nconst makeCreator = (arg) => {\n    if (arg !== undefined &&\n        Object.prototype.toString.call(arg) !== '[object Object]') {\n        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);\n    }\n    return function create(arg0, arg1, arg2) {\n        var _a, _b, _c;\n        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n            return function (base, ...args) {\n                return create(base, (draft) => arg0.call(this, draft, ...args), arg1);\n            };\n        }\n        const base = arg0;\n        const mutate = arg1;\n        let options = arg2;\n        if (typeof arg1 !== 'function') {\n            options = arg1;\n        }\n        if (options !== undefined &&\n            Object.prototype.toString.call(options) !== '[object Object]') {\n            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);\n        }\n        options = Object.assign(Object.assign({}, arg), options);\n        const state = isDraft(base) ? current(base) : base;\n        const mark = Array.isArray(options.mark)\n            ? ((value, types) => {\n                for (const mark of options.mark) {\n                    if (typeof mark !== 'function') {\n                        throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);\n                    }\n                    const result = mark(value, types);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return;\n            })\n            : options.mark;\n        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;\n        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;\n        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;\n        const _options = {\n            enableAutoFreeze,\n            mark,\n            strict,\n            enablePatches,\n        };\n        if (!isDraftable(state, _options) &&\n            typeof state === 'object' &&\n            state !== null) {\n            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n        }\n        const [draft, finalize] = draftify(state, _options);\n        if (typeof arg1 !== 'function') {\n            if (!isDraftable(state, _options)) {\n                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);\n            }\n            return [draft, finalize];\n        }\n        let result;\n        try {\n            result = mutate(draft);\n        }\n        catch (error) {\n            revokeProxy(getProxyDraft(draft));\n            throw error;\n        }\n        const returnValue = (value) => {\n            const proxyDraft = getProxyDraft(draft);\n            if (!isDraft(value)) {\n                if (value !== undefined &&\n                    !isEqual(value, draft) &&\n                    (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {\n                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);\n                }\n                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];\n                if (rawReturnValue) {\n                    const _value = rawReturnValue[0];\n                    if (_options.strict && typeof value === 'object' && value !== null) {\n                        handleReturnValue({\n                            rootDraft: proxyDraft,\n                            value,\n                            useRawReturn: true,\n                        });\n                    }\n                    return finalize([_value]);\n                }\n                if (value !== undefined) {\n                    if (typeof value === 'object' && value !== null) {\n                        handleReturnValue({ rootDraft: proxyDraft, value });\n                    }\n                    return finalize([value]);\n                }\n            }\n            if (value === draft || value === undefined) {\n                return finalize([]);\n            }\n            const returnedProxyDraft = getProxyDraft(value);\n            if (_options === returnedProxyDraft.options) {\n                if (returnedProxyDraft.operated) {\n                    throw new Error(`Cannot return a modified child draft.`);\n                }\n                return finalize([current(value)]);\n            }\n            return finalize([value]);\n        };\n        if (result instanceof Promise) {\n            return result.then(returnValue, (error) => {\n                revokeProxy(getProxyDraft(draft));\n                throw error;\n            });\n        }\n        return returnValue(result);\n    };\n};\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nfunction apply(state, patches, applyOptions) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i -= 1) {\n        const { value, op, path } = patches[i];\n        if ((!path.length && op === Operation.Replace) ||\n            (path === '' && op === Operation.Add)) {\n            state = value;\n            break;\n        }\n    }\n    if (i > -1) {\n        patches = patches.slice(i + 1);\n    }\n    const mutate = (draft) => {\n        patches.forEach((patch) => {\n            const { path: _path, op } = patch;\n            const path = unescapePath(_path);\n            let base = draft;\n            for (let index = 0; index < path.length - 1; index += 1) {\n                const parentType = getType(base);\n                let key = path[index];\n                if (typeof key !== 'string' && typeof key !== 'number') {\n                    key = String(key);\n                }\n                if (((parentType === 0 /* DraftType.Object */ ||\n                    parentType === 1 /* DraftType.Array */) &&\n                    (key === '__proto__' || key === 'constructor')) ||\n                    (typeof base === 'function' && key === 'prototype')) {\n                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);\n                }\n                // use `index` in Set draft\n                base = get(parentType === 3 /* DraftType.Set */ ? Array.from(base) : base, key);\n                if (typeof base !== 'object') {\n                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n                }\n            }\n            const type = getType(base);\n            // ensure the original patch is not modified.\n            const value = deepClone(patch.value);\n            const key = path[path.length - 1];\n            switch (op) {\n                case Operation.Replace:\n                    switch (type) {\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            throw new Error(`Cannot apply replace patch to set.`);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Add:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            // If the \"-\" character is used to\n                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n                            // this has the effect of appending the value to the array.\n                            return key === '-'\n                                ? base.push(value)\n                                : base.splice(key, 0, value);\n                        case 2 /* DraftType.Map */:\n                            return base.set(key, value);\n                        case 3 /* DraftType.Set */:\n                            return base.add(value);\n                        default:\n                            return (base[key] = value);\n                    }\n                case Operation.Remove:\n                    switch (type) {\n                        case 1 /* DraftType.Array */:\n                            return base.splice(key, 1);\n                        case 2 /* DraftType.Map */:\n                            return base.delete(key);\n                        case 3 /* DraftType.Set */:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    throw new Error(`Unsupported patch operation: ${op}.`);\n            }\n        });\n    };\n    if (applyOptions === null || applyOptions === void 0 ? void 0 : applyOptions.mutable) {\n        {\n            if (Object.keys(applyOptions).filter((key) => key !== 'mutable').length) {\n                console.warn('The \"mutable\" option is not allowed to be used with other options.');\n            }\n        }\n        mutate(state);\n        return undefined;\n    }\n    if (isDraft(state)) {\n        if (applyOptions !== undefined) {\n            throw new Error(`Cannot apply patches with options to a draft.`);\n        }\n        mutate(state);\n        return state;\n    }\n    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), { enablePatches: false }));\n}\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nfunction original(target) {\n    const proxyDraft = getProxyDraft(target);\n    if (!proxyDraft) {\n        throw new Error(`original() is only used for a draft, parameter: ${target}`);\n    }\n    return proxyDraft.original;\n}\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nfunction rawReturn(value) {\n    if (arguments.length === 0) {\n        throw new Error('rawReturn() must be called with a value.');\n    }\n    if (arguments.length > 1) {\n        throw new Error('rawReturn() must be called with one argument.');\n    }\n    if (value !== undefined &&\n        (typeof value !== 'object' || value === null)) {\n        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');\n    }\n    return {\n        [RAW_RETURN_SYMBOL]: [value],\n    };\n}\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value) => {\n    if (!value || typeof value !== 'object')\n        return false;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null) {\n        return true;\n    }\n    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') &&\n        prototype.constructor;\n    if (constructor === Object)\n        return true;\n    return (typeof constructor === 'function' &&\n        Function.toString.call(constructor) === constructorString);\n};\nconst markSimpleObject = (value) => {\n    if (isSimpleObject(value)) {\n        return dataTypes.immutable;\n    }\n    return;\n};\n\n/**\n * Cast a value to an Draft type value.\n */\nfunction castDraft(value) {\n    return value;\n}\n/**\n * Cast a value to an Immutable type value.\n */\nfunction castImmutable(value) {\n    return value;\n}\n/**\n * Cast a value to an Mutable type value.\n */\nfunction castMutable(draft) {\n    return draft;\n}\n\nexport { apply, castDraft, castImmutable, castMutable, create, current, isDraft, isDraftable, makeCreator, markSimpleObject, original, rawReturn, unsafe };\n//# sourceMappingURL=mutative.esm.mjs.map\n","import { useMemo as i, useCallback as r, useSyncExternalStore as u } from \"react\";\r\nimport { signal as f, effect as a } from \"@preact/signals-core\";\r\nimport { Computed as C, Effect as E, Signal as j, batch as w, computed as D, effect as M, signal as q, untracked as z } from \"@preact/signals-core\";\r\nimport { create as l, isDraft as m, rawReturn as v } from \"mutative\";\r\nexport * from \"mutative\";\r\nconst S = (e, t) => typeof t == \"function\" ? l(e.value, (s) => {\r\n  const n = t(s);\r\n  return typeof n > \"u\" || m(n) ? s : typeof n == \"object\" ? v(n) : n;\r\n}) : t, F = (e, t) => (e.value = S(e, t), e.value), b = (e) => {\r\n  const t = f(e);\r\n  return t.set = (o) => F(t, o), t;\r\n}, g = (e) => {\r\n  const t = i(() => b(e), []), o = r(() => t.value, [t]), s = () => t.peek(), n = r((p) => a(() => {\r\n    p(t.value);\r\n  }), [t]);\r\n  return [u(\r\n    n,\r\n    o,\r\n    s\r\n  ), t.set];\r\n}, k = (e) => {\r\n  const t = r(() => e.value, [e]), o = () => e.peek(), s = r((c) => a(() => {\r\n    c(e.value);\r\n  }), [e]);\r\n  return u(\r\n    s,\r\n    t,\r\n    o\r\n  );\r\n};\r\nexport {\r\n  C as Computed,\r\n  E as Effect,\r\n  j as Signal,\r\n  w as batch,\r\n  D as computed,\r\n  b as createSignal,\r\n  M as effect,\r\n  q as signal,\r\n  z as untracked,\r\n  g as useReactive,\r\n  k as useReactiveSignal\r\n};\r\n//# sourceMappingURL=reactSetSignal.js.map\r\n"],"names":["Operation","PROXY_DRAFT","RAW_RETURN_SYMBOL","iteratorSymbol","dataTypes","internal","has","target","key","getDescriptor","prototype","descriptor","isBaseSetInstance","obj","isBaseMapInstance","latest","proxyDraft","_a","isDraft","getProxyDraft","value","getValue","isDraftable","options","markResult","getPath","path","parentCopy","get","isSet","resolvePath","getType","set","peek","state","isEqual","x","y","revokeProxy","escapePath","pathAsArray","_item","item","base","index","strictCopy","copy","desc","propIsEnum","shallowCopy","original","SubClass","ensureShallowCopy","deepClone","iterable","k","v","cloneIfNeeded","markChanged","throwFrozenError","deepFreeze","subKey","updatedValues","stack","keys","parent","name","forEach","iter","type","entry","handleValue","handledSet","setMap","updatedValue","values","finalizeAssigned","finalizeSetValue","finalizePatches","generatePatches","patches","inversePatches","basePath","markFinalization","generateArrayPatches","proxyState","assignedMap","_path","arrayLengthAssignment","generatePatchesFromAssigned","assignedValue","originalValue","op","generateSetPatches","checkReadable","ignoreCheckDraftable","mapHandler","source","callback","thisArg","_value","_key","_b","mutable","draft","iterator","result","mapHandlerKeys","getNextIterator","isValuesIterator","currentDraft","proxy","setHandler","valueProxyDraft","other","setHandlerKeys","proxyHandler","receiver","createDraft","subProxyDraft","current","currentProxyDraft","createDraftOptions","parentDraft","finalities","revoke","oldProxyDraft","finalizeDraft","returnedValue","enableAutoFreeze","hasReturnedValue","draftify","baseState","finalizedState","finalizedPatches","finalizedInversePatches","handleReturnValue","rootDraft","useRawReturn","isRoot","currentValue","arr","getCurrent","newValue","makeCreator","arg","create","arg0","arg1","arg2","_c","args","mutate","mark","types","enablePatches","strict","_options","finalize","error","returnValue","rawReturnValue","returnedProxyDraft","rawReturn","S","t","l","s","n","m","F","b","f","o","g","i","r","p","a","u","c"],"mappings":"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","x_google_ignoreList":[0,1]}